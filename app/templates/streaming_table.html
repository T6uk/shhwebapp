{% extends "base.html" %}

{% block title %}{{ table_name }} - Big Data Web App (Streaming){% endblock %}

{% block head %}
<style>
    .edit-controls {
        display: none;
    }
    tr.editing .edit-controls {
        display: inline-block;
    }
    tr.editing .view-controls {
        display: none;
    }
    .table-container {
        overflow-x: auto;
        max-height: 70vh;
    }
    /* Sticky header */
    thead th {
        position: sticky;
        top: 0;
        background-color: #f8f9fa;
        z-index: 2;
    }
    /* Highlight edited cells */
    td.edited {
        background-color: rgba(255, 255, 0, 0.2);
        transition: background-color 3s;
    }
    /* Highlight new data */
    tr.new-data {
        animation: newRowHighlight 3s;
    }
    @keyframes newRowHighlight {
        0% { background-color: rgba(144, 238, 144, 0.5); }
        100% { background-color: transparent; }
    }
    /* Highlight updated data */
    tr.updated {
        animation: updatedRowHighlight 3s;
    }
    @keyframes updatedRowHighlight {
        0% { background-color: rgba(255, 255, 0, 0.3); }
        100% { background-color: transparent; }
    }
    /* Loading overlay */
    #loading-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        background-color: rgba(255, 255, 255, 0.8);
        z-index: 1000;
    }
    .progress-container {
        width: 50%;
        margin: 20px 0;
    }
    /* Quick filter */
    .quick-filter {
        width: 300px;
        display: inline-block;
    }
    /* Connection status */
    .connection-status {
        display: inline-flex;
        align-items: center;
        margin-left: 15px;
        padding: 5px 10px;
        border-radius: 15px;
        font-size: 0.9rem;
    }
    .connection-status.connected {
        background-color: rgba(40, 167, 69, 0.2);
        color: #28a745;
    }
    .connection-status.connecting {
        background-color: rgba(255, 193, 7, 0.2);
        color: #ffc107;
    }
    .connection-status.disconnected {
        background-color: rgba(220, 53, 69, 0.2);
        color: #dc3545;
    }
    .connection-status .status-indicator {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        margin-right: 5px;
    }
    .connection-status.connected .status-indicator {
        background-color: #28a745;
    }
    .connection-status.connecting .status-indicator {
        background-color: #ffc107;
    }
    .connection-status.disconnected .status-indicator {
        background-color: #dc3545;
    }
    /* Column selection dropdown */
    .column-dropdown {
        max-height: 400px;
        overflow-y: auto;
    }
    /* Auto-update toggle */
    .auto-update-toggle {
        display: flex;
        align-items: center;
    }
    #auto-update-messages {
        margin-left: 10px;
        font-size: 0.85rem;
        color: #6c757d;
    }
</style>
{% endblock %}

{% block content %}
<div class="container-fluid mt-4">
    <div class="row">
        <div class="col-12">
            <div class="card shadow">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <div>
                        <h2>{{ table_name }} <small class="text-muted">(Streaming)</small></h2>
                        <div class="connection-status disconnected">
                            <div class="status-indicator"></div>
                            <span class="status-text">Disconnected</span>
                        </div>
                    </div>
                    <div class="input-group quick-filter">
                        <input type="text" id="quick-filter" class="form-control" placeholder="Search...">
                        <button class="btn btn-outline-secondary" type="button" id="clear-filter">
                            <i class="bi bi-x"></i>
                        </button>
                    </div>
                </div>

                <div class="p-2 bg-light border-top border-bottom">
                    <div class="d-flex flex-wrap gap-2">
                        <div class="btn-group">
                            <button id="refresh-btn" class="btn btn-outline-primary">
                                <i class="bi bi-arrow-clockwise"></i> Refresh
                            </button>
                            <button id="load-more-btn" class="btn btn-outline-primary">
                                <i class="bi bi-download"></i> Load More
                            </button>
                        </div>

                        <div class="btn-group">
                            <button class="btn btn-outline-secondary dropdown-toggle" type="button" data-bs-toggle="dropdown">
                                <i class="bi bi-columns"></i> Columns
                            </button>
                            <div class="dropdown-menu column-dropdown" id="column-dropdown">
                                <div class="px-3 py-2">
                                    <div class="mb-2">
                                        <div class="form-check">
                                            <input class="form-check-input" type="checkbox" id="toggle-all-columns">
                                            <label class="form-check-label" for="toggle-all-columns">
                                                <strong>Select All</strong>
                                            </label>
                                        </div>
                                    </div>
                                    <hr>
                                    <div id="column-checkboxes">
                                        <!-- Column checkboxes will be added dynamically -->
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div class="btn-group">
                            <button id="export-btn" class="btn btn-outline-success">
                                <i class="bi bi-file-earmark-excel"></i> Export
                            </button>
                            <button id="clear-cache-btn" class="btn btn-outline-danger">
                                <i class="bi bi-trash"></i> Clear Cache
                            </button>
                        </div>

                        <div class="auto-update-toggle ms-3">
                            <div class="form-check form-switch">
                                <input class="form-check-input" type="checkbox" id="auto-update-toggle" checked>
                                <label class="form-check-label" for="auto-update-toggle">Auto-update</label>
                            </div>
                            <span id="auto-update-messages"></span>
                        </div>
                    </div>
                </div>

                <div class="card-body position-relative">
                    <!-- Loading overlay -->
                    <div id="loading-overlay">
                        <h4 id="loading-text">Connecting...</h4>
                        <div class="spinner-border text-primary"></div>
                        <div class="progress-container">
                            <div class="progress">
                                <div id="loading-progress" class="progress-bar progress-bar-striped progress-bar-animated"
                                     role="progressbar" style="width: 0%"></div>
                            </div>
                        </div>
                        <div id="loading-status" class="text-muted mt-2">Initializing connection...</div>
                    </div>

                    <!-- Error alert -->
                    <div id="error-message" class="alert alert-danger" style="display: none;"></div>

                    <!-- Data stats -->
                    <div class="d-flex justify-content-between mb-3">
                        <div id="data-stats" class="text-muted">
                            <span id="loaded-count">0</span> of <span id="total-count">0</span> rows loaded
                        </div>
                        <div class="pagination-controls">
                            <button id="prev-page" class="btn btn-sm btn-outline-secondary" disabled>
                                <i class="bi bi-chevron-left"></i>
                            </button>
                            <span id="page-info" class="mx-2">Page 1</span>
                            <button id="next-page" class="btn btn-sm btn-outline-secondary">
                                <i class="bi bi-chevron-right"></i>
                            </button>
                        </div>
                    </div>

                    <!-- Table -->
                    <div class="table-container">
                        <table id="data-table" class="table table-striped table-bordered w-100">
                            <thead>
                                <tr id="table-header">
                                    <!-- Table headers will be added dynamically -->
                                </tr>
                            </thead>
                            <tbody id="table-body">
                                <tr>
                                    <td colspan="100%" class="text-center">Loading data...</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
// WebSocket connection
let ws;
let tableColumns = [];
let visibleColumns = [];
let tableData = [];
let totalRows = 0;
let loadedRows = 0;
let chunkSize = {{ stream_chunk_size }};
let currentPage = 1;
let pageSize = 50;
let isLoading = false;
let autoUpdate = true;
let searchValue = '';
let sortColumn = null;
let sortDirection = 'asc';
let retryCount = 0;
let maxRetries = 5;
let retryDelay = 2000;

// Initialize on page load
document.addEventListener('DOMContentLoaded', function() {
    // Initialize WebSocket if enabled
    {% if enable_websockets %}
    initWebSocket();
    {% else %}
    document.getElementById('loading-text').textContent = "Loading Data...";
    document.getElementById('loading-status').textContent = "WebSockets disabled, using HTTP fallback";
    loadSchemaHttp();
    {% endif %}

    // Attach event handlers
    attachEventHandlers();

    // Load saved column preferences
    loadColumnPreferences();

    // Restore search value from URL
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.has('search')) {
        searchValue = urlParams.get('search');
        document.getElementById('quick-filter').value = searchValue;
    }
});

// Initialize WebSocket connection
function initWebSocket() {
    updateConnectionStatus('connecting');

    // Close existing connection if any
    if (ws) {
        ws.close();
    }

    // Create new WebSocket connection
    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    const wsUrl = `${protocol}//${window.location.host}/api/ws/table/{{ table_name }}`;

    ws = new WebSocket(wsUrl);

    ws.onopen = function() {
        console.log('WebSocket connected');
        updateConnectionStatus('connected');
        retryCount = 0;

        // Request schema information
        fetchTableSchema();
    };

    ws.onmessage = function(event) {
        const message = JSON.parse(event.data);
        console.log('WebSocket message received:', message.type);

        switch(message.type) {
            case 'connection_established':
                document.getElementById('loading-status').textContent = 'Connected, fetching schema...';
                break;

            case 'schema':
                handleSchemaData(message.columns);
                startDataLoading();
                break;

            case 'data_chunk':
                handleDataChunk(message);
                break;

            case 'row_updated':
                if (autoUpdate) {
                    handleRowUpdate(message.row_id, message.data);
                    showAutoUpdateMessage(`Row ${message.row_id} updated`);
                }
                break;

            case 'cache_cleared':
                if (message.success) {
                    showToast('Cache cleared successfully');
                    refreshData();
                }
                break;

            case 'error':
                showError(`WebSocket error: ${message.message}`);
                break;
        }
    };

    ws.onclose = function() {
        console.log('WebSocket disconnected');
        updateConnectionStatus('disconnected');

        // Retry connection if not max retries
        if (retryCount < maxRetries) {
            retryCount++;
            const delay = retryDelay * retryCount;
            console.log(`Retrying connection in ${delay}ms (attempt ${retryCount}/${maxRetries})`);
            document.getElementById('loading-status').textContent = `Connection lost. Retrying in ${delay/1000}s...`;

            setTimeout(initWebSocket, delay);
        } else {
            document.getElementById('loading-status').textContent = 'Connection failed. Using HTTP fallback...';
            // Fall back to HTTP requests
            loadSchemaHttp();
        }
    };

    ws.onerror = function(error) {
        console.error('WebSocket error:', error);
        showError('WebSocket connection error');
    };
}

// Fetch table schema via WebSocket
function fetchTableSchema() {
    if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({
            command: 'get_schema',
            table: '{{ table_name }}'
        }));
    } else {
        loadSchemaHttp();
    }
}

// Start loading data chunks
function startDataLoading() {
    loadDataChunk(0, chunkSize);
}

// Load a chunk of data via WebSocket
function loadDataChunk(start, size) {
    if (isLoading) return;

    isLoading = true;
    updateLoadingProgress(0, `Loading data (${start} to ${start + size})...`);
    showLoadingOverlay(true);

    if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({
            command: 'fetch_data',
            start: start,
            chunk_size: size,
            search: searchValue,
            sort_by: sortColumn,
            sort_desc: sortDirection === 'desc'
        }));
    } else {
        // Fallback to HTTP
        loadDataChunkHttp(start, size);
    }
}

// Fallback to HTTP for schema
function loadSchemaHttp() {
    fetch(`/api/table/{{ table_name }}/schema`)
        .then(response => {
            if (!response.ok) {
                throw new Error(`HTTP error: ${response.status}`);
            }
            return response.json();
        })
        .then(data => {
            handleSchemaData(data.columns);
            startDataLoading();
        })
        .catch(error => {
            showError(`Error loading schema: ${error.message}`);
        });
}

// Fallback to HTTP for data
function loadDataChunkHttp(start, size) {
    const url = `/api/table/{{ table_name }}/data?start=${start}&length=${size}&search[value]=${encodeURIComponent(searchValue)}`;

    fetch(url)
        .then(response => {
            if (!response.ok) {
                throw new Error(`HTTP error: ${response.status}`);
            }
            return response.json();
        })
        .then(data => {
            const message = {
                type: 'data_chunk',
                start: start,
                total: data.recordsTotal,
                data: data.data
            };
            handleDataChunk(message);
        })
        .catch(error => {
            isLoading = false;
            showError(`Error loading data: ${error.message}`);
            showLoadingOverlay(false);
        });
}

// Handle schema data
function handleSchemaData(columns) {
    tableColumns = columns.map(col => ({
        ...col,
        visible: true // Default all columns to visible
    }));

    // Save original column order
    tableColumns.forEach((col, index) => {
        col.originalIndex = index;
    });

    // If we've loaded column preferences before, apply them
    applyColumnVisibility();

    // Set visible columns
    visibleColumns = tableColumns.filter(col => col.visible);

    // Create table header
    createTableHeader();

    updateLoadingProgress(20, 'Schema loaded, fetching data...');
}

// Handle data chunk received
function handleDataChunk(message) {
    const { start, total, data } = message;

    // Update totals
    totalRows = total;

    // If first chunk, clear table
    if (start === 0) {
        tableData = [];
    }

    // Add new data
    if (data && data.length > 0) {
        tableData = tableData.concat(data);
        loadedRows = tableData.length;
    }

    // Update UI
    updateLoadingProgress(Math.min(90, (loadedRows / Math.min(totalRows, 1000)) * 100),
        `Loaded ${loadedRows} of ${totalRows} rows...`);

    updateDataStats();
    renderTableData();

    // Hide loading overlay when we've loaded a significant amount of data
    // or we've loaded everything
    if (loadedRows >= Math.min(totalRows, 1000) || loadedRows >= totalRows) {
        updateLoadingProgress(100, 'Data loaded successfully');
        showLoadingOverlay(false);
    }

    isLoading = false;

    // If we haven't loaded all data and we're below a certain threshold,
    // automatically load the next chunk
    if (loadedRows < totalRows && loadedRows < 1000) {
        loadDataChunk(loadedRows, chunkSize);
    }
}

// Handle row update
function handleRowUpdate(rowId, rowData) {
    // Find the row in our data
    const index = tableData.findIndex(row => row.id == rowId);

    if (index !== -1) {
        // Update the data
        tableData[index] = rowData;

        // Re-render the table to show the update
        renderTableData();

        // Highlight the updated row
        const rowElement = document.querySelector(`#table-body tr[data-id="${rowId}"]`);
        if (rowElement) {
            rowElement.classList.add('updated');
            setTimeout(() => {
                rowElement.classList.remove('updated');
            }, 3000);
        }
    } else {
        // Row not in our current view, consider refreshing data
        if (autoUpdate) {
            showAutoUpdateMessage('Received update for row not in current view');
        }
    }
}

// Create table header based on visible columns
function createTableHeader() {
    const headerRow = document.getElementById('table-header');
    headerRow.innerHTML = '';

    visibleColumns.forEach(column => {
        const th = document.createElement('th');
        th.textContent = column.name;
        th.dataset.column = column.name;
        th.classList.add('sortable');

        // Add sort indicator if this is the current sort column
        if (column.name === sortColumn) {
            th.classList.add(sortDirection === 'asc' ? 'sorting_asc' : 'sorting_desc');
        }

        // Add click event for sorting
        th.addEventListener('click', () => {
            handleSort(column.name);
        });

        headerRow.appendChild(th);
    });

    // Add actions column
    const actionsHeader = document.createElement('th');
    actionsHeader.textContent = 'Actions';
    actionsHeader.style.width = '100px';
    headerRow.appendChild(actionsHeader);
}

// Render table data for current page
function renderTableData() {
    const tableBody = document.getElementById('table-body');

    // Calculate page bounds
    const startIdx = (currentPage - 1) * pageSize;
    const endIdx = Math.min(startIdx + pageSize, tableData.length);

    // Clear existing rows
    tableBody.innerHTML = '';

    // If no data
    if (tableData.length === 0) {
        const noDataRow = document.createElement('tr');
        const noDataCell = document.createElement('td');

        noDataCell.colSpan = visibleColumns.length + 1; // +1 for actions
        noDataCell.textContent = 'No data found';
        noDataCell.className = 'text-center';

        noDataRow.appendChild(noDataCell);
        tableBody.appendChild(noDataRow);
        return;
    }

    // Create rows for current page
    for (let i = startIdx; i < endIdx; i++) {
        const rowData = tableData[i];
        const row = document.createElement('tr');
        row.dataset.id = rowData.id || i;

        // Add data cells
        visibleColumns.forEach(column => {
            const cell = document.createElement('td');
            const value = rowData[column.name];

            // Format cell value based on type
            if (value === null || value === undefined) {
                cell.innerHTML = '<span class="text-muted">-</span>';
            } else if (column.type === 'boolean') {
                cell.innerHTML = value ?
                    '<span class="badge bg-success">Yes</span>' :
                    '<span class="badge bg-secondary">No</span>';
            } else if (column.type === 'datetime' && value) {
                // Try to format as date if it looks like a date
                try {
                    const date = new Date(value);
                    if (!isNaN(date)) {
                        cell.textContent = date.toLocaleDateString();
                    } else {
                        cell.textContent = value;
                    }
                } catch (e) {
                    cell.textContent = value;
                }
            } else {
                cell.textContent = value;
            }

            row.appendChild(cell);
        });

        // Add actions cell
        const actionsCell = document.createElement('td');
        actionsCell.innerHTML = `
            <div class="btn-group btn-group-sm">
                <button class="btn btn-outline-primary edit-btn view-controls">Edit</button>
                <button class="btn btn-success save-btn edit-controls">Save</button>
                <button class="btn btn-danger cancel-btn edit-controls">Cancel</button>
            </div>
        `;
        row.appendChild(actionsCell);

        // Add row to table
        tableBody.appendChild(row);
    }

    // Update pagination UI
    document.getElementById('prev-page').disabled = currentPage === 1;
    document.getElementById('next-page').disabled = endIdx >= tableData.length;
    document.getElementById('page-info').textContent = `Page ${currentPage}`;
}

// Attach event handlers
function attachEventHandlers() {
    // Refresh button
    document.getElementById('refresh-btn').addEventListener('click', refreshData);

    // Load more button
    document.getElementById('load-more-btn').addEventListener('click', () => {
        loadDataChunk(loadedRows, chunkSize);
    });

    // Previous page
    document.getElementById('prev-page').addEventListener('click', () => {
        if (currentPage > 1) {
            currentPage--;
            renderTableData();
        }
    });

    // Next page
    document.getElementById('next-page').addEventListener('click', () => {
        if ((currentPage * pageSize) < tableData.length) {
            currentPage++;
            renderTableData();
        }
    });

    // Search input
    const searchInput = document.getElementById('quick-filter');
    let searchTimeout;

    searchInput.addEventListener('input', () => {
        clearTimeout(searchTimeout);
        searchTimeout = setTimeout(() => {
            const newSearchValue = searchInput.value.trim();
            if (newSearchValue !== searchValue) {
                searchValue = newSearchValue;
                refreshData();

                // Update URL with search parameter
                const url = new URL(window.location);
                if (searchValue) {
                    url.searchParams.set('search', searchValue);
                } else {
                    url.searchParams.delete('search');
                }
                window.history.replaceState({}, '', url);
            }
        }, 300);
    });

    // Clear search button
    document.getElementById('clear-filter').addEventListener('click', () => {
        searchInput.value = '';
        searchValue = '';
        refreshData();

        // Update URL
        const url = new URL(window.location);
        url.searchParams.delete('search');
        window.history.replaceState({}, '', url);
    });

    // Export button
    document.getElementById('export-btn').addEventListener('click', exportData);

    // Clear cache button
    document.getElementById('clear-cache-btn').addEventListener('click', clearCache);

    // Auto-update toggle
    document.getElementById('auto-update-toggle').addEventListener('change', function() {
        autoUpdate = this.checked;
        showAutoUpdateMessage(autoUpdate ? 'Auto-update enabled' : 'Auto-update disabled');
    });

    // Toggle all columns checkbox
    document.getElementById('toggle-all-columns').addEventListener('change', function() {
        const checkboxes = document.querySelectorAll('#column-checkboxes input[type="checkbox"]');
        checkboxes.forEach(checkbox => {
            checkbox.checked = this.checked;
        });
    });

    // Row edit/save/cancel functionality
    document.addEventListener('click', function(e) {
        if (e.target.classList.contains('edit-btn')) {
            handleEdit(e.target);
        } else if (e.target.classList.contains('save-btn')) {
            handleSave(e.target);
        } else if (e.target.classList.contains('cancel-btn')) {
            handleCancel(e.target);
        }
    });
}

// Create column checkboxes
function createColumnCheckboxes() {
    const container = document.getElementById('column-checkboxes');
    container.innerHTML = '';

    tableColumns.forEach(column => {
        const div = document.createElement('div');
        div.className = 'form-check';

        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.className = 'form-check-input column-checkbox';
        checkbox.id = `col-${column.name}`;
        checkbox.checked = column.visible;
        checkbox.dataset.column = column.name;

        const label = document.createElement('label');
        label.className = 'form-check-label';
        label.htmlFor = `col-${column.name}`;
        label.textContent = column.name;

        div.appendChild(checkbox);
        div.appendChild(label);
        container.appendChild(div);

        // Add change event
        checkbox.addEventListener('change', function() {
            updateColumnVisibility();
        });
    });
}

// Update column visibility based on checkboxes
function updateColumnVisibility() {
    // Get all checkboxes
    const checkboxes = document.querySelectorAll('.column-checkbox');

    // Update visible status on tableColumns
    checkboxes.forEach(checkbox => {
        const columnName = checkbox.dataset.column;
        const column = tableColumns.find(col => col.name === columnName);
        if (column) {
            column.visible = checkbox.checked;
        }
    });

    // Save preferences
    saveColumnPreferences();

    // Update visible columns and re-render
    visibleColumns = tableColumns.filter(col => col.visible);
    createTableHeader();
    renderTableData();
}

// Save column preferences to localStorage
function saveColumnPreferences() {
    try {
        const preferences = tableColumns.map(col => ({
            name: col.name,
            visible: col.visible
        }));

        localStorage.setItem('column_prefs_{{ table_name }}', JSON.stringify(preferences));
    } catch (e) {
        console.error('Error saving column preferences:', e);
    }
}

// Load column preferences from localStorage
function loadColumnPreferences() {
    try {
        const saved = localStorage.getItem('column_prefs_{{ table_name }}');
        if (saved) {
            const preferences = JSON.parse(saved);

            // We'll apply these after we get the actual schema
            window.savedColumnPreferences = preferences;
        }
    } catch (e) {
        console.error('Error loading column preferences:', e);
    }
}

// Apply saved column preferences
function applyColumnVisibility() {
    if (window.savedColumnPreferences) {
        window.savedColumnPreferences.forEach(pref => {
            const column = tableColumns.find(col => col.name === pref.name);
            if (column) {
                column.visible = pref.visible;
            }
        });

        // Create column checkboxes with saved states
        createColumnCheckboxes();
    } else {
        // No saved preferences, create checkboxes with defaults
        createColumnCheckboxes();
    }
}

// Refresh all data
function refreshData() {
    // Reset data
    tableData = [];
    loadedRows = 0;
    currentPage = 1;

    // Start loading first chunk
    loadDataChunk(0, chunkSize);
}

// Handle sort click
function handleSort(columnName) {
    // If clicking the same column, toggle direction
    if (columnName === sortColumn) {
        sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
    } else {
        // New column, default to ascending
        sortColumn = columnName;
        sortDirection = 'asc';
    }

    // Update header UI
    const headers = document.querySelectorAll('#table-header th');
    headers.forEach(header => {
        header.classList.remove('sorting_asc', 'sorting_desc');
        if (header.dataset.column === sortColumn) {
            header.classList.add(sortDirection === 'asc' ? 'sorting_asc' : 'sorting_desc');
        }
    });

    // Refresh data with new sort
    refreshData();
}

// Handle row edit
function handleEdit(button) {
    const row = button.closest('tr');
    const rowId = row.dataset.id;
    const rowData = tableData.find(data => data.id == rowId);

    if (!rowData) return;

    // Mark row as being edited
    row.classList.add('editing');

    // Replace cell contents with input fields
    const cells = row.querySelectorAll('td');

    visibleColumns.forEach((column, index) => {
        const cell = cells[index];
        const value = rowData[column.name] || '';
        const originalContent = cell.innerHTML;

        cell.dataset.original = originalContent;

        // Create appropriate input based on column type
        let inputField;

        switch(column.type) {
            case 'boolean':
                inputField = `<select class="form-control form-control-sm edit-field"
                              data-column="${column.name}">
                              <option value="true" ${value ? 'selected' : ''}>Yes</option>
                              <option value="false" ${!value ? 'selected' : ''}>No</option>
                              </select>`;
                break;

            case 'datetime':
                // Try to format date for input
                let dateValue = '';
                if (value) {
                    try {
                        const date = new Date(value);
                        if (!isNaN(date)) {
                            dateValue = date.toISOString().split('T')[0];
                        } else {
                            dateValue = value;
                        }
                    } catch (e) {
                        dateValue = value;
                    }
                }

                inputField = `<input type="date" class="form-control form-control-sm edit-field"
                              value="${dateValue}" data-column="${column.name}">`;
                break;

            case 'integer':
            case 'number':
                inputField = `<input type="number" class="form-control form-control-sm edit-field"
                              value="${value}" data-column="${column.name}" step="any">`;
                break;

            case 'text':
                if (value && value.length > 100) {
                    inputField = `<textarea class="form-control form-control-sm edit-field"
                                  data-column="${column.name}" rows="3">${value}</textarea>`;
                } else {
                    inputField = `<input type="text" class="form-control form-control-sm edit-field"
                                  value="${value}" data-column="${column.name}">`;
                }
                break;

            default:
                inputField = `<input type="text" class="form-control form-control-sm edit-field"
                              value="${value}" data-column="${column.name}">`;
        }

        cell.innerHTML = inputField;
    });
}

// Handle save button click
function handleSave(button) {
    const row = button.closest('tr');
    const rowId = row.dataset.id;
    const rowIdx = tableData.findIndex(data => data.id == rowId);

    if (rowIdx === -1) return;

    const rowData = {...tableData[rowIdx]};
    const updatedData = {...rowData};

    // Collect values from all input fields
    const inputs = row.querySelectorAll('.edit-field');
    inputs.forEach(input => {
        const columnName = input.dataset.column;
        let value = input.value;

        // Convert value based on column type
        const column = tableColumns.find(col => col.name === columnName);
        if (column) {
            switch(column.type) {
                case 'boolean':
                    value = value === 'true';
                    break;

                case 'integer':
                    value = parseInt(value, 10);
                    break;

                case 'number':
                    value = parseFloat(value);
                    break;
            }
        }

        updatedData[columnName] = value;
    });

    // Save via WebSocket or HTTP
    saveRowData(rowId, updatedData, row);
}

// Handle cancel button
function handleCancel(button) {
    const row = button.closest('tr');

    // Restore original content
    const cells = row.querySelectorAll('td');
    visibleColumns.forEach((column, index) => {
        const cell = cells[index];
        if (cell.dataset.original) {
            cell.innerHTML = cell.dataset.original;
            delete cell.dataset.original;
        }
    });

    // Remove editing class
    row.classList.remove('editing');
}

// Save row data via WebSocket or HTTP
function saveRowData(rowId, data, rowElement) {
    // If WebSocket is available, send update via WebSocket
    if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({
            command: 'update_row',
            row_id: rowId,
            data: data
        }));

        // Optimistically update UI
        updateRowInTable(rowId, data, rowElement);
        return;
    }

    // Otherwise, fall back to HTTP
    fetch(`/api/table/{{ table_name }}/rows/${rowId}`, {
        method: 'PUT',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(data)
    })
    .then(response => {
        if (!response.ok) {
            throw new Error(`HTTP error: ${response.status}`);
        }
        return response.json();
    })
    .then(result => {
        if (result.success) {
            updateRowInTable(rowId, data, rowElement);
        } else {
            showError(`Error updating row: ${result.message}`);
        }
    })
    .catch(error => {
        showError(`Error saving data: ${error.message}`);
    });
}

// Update a row in the table after save
function updateRowInTable(rowId, data, rowElement) {
    // Update data in memory
    const rowIdx = tableData.findIndex(row => row.id == rowId);
    if (rowIdx !== -1) {
        tableData[rowIdx] = data;
    }

    // Remove editing class
    rowElement.classList.remove('editing');

    // Restore cells with new data
    const cells = rowElement.querySelectorAll('td');

    visibleColumns.forEach((column, index) => {
        const cell = cells[index];
        const value = data[column.name];

        // Format value based on type, similar to renderTableData
        if (value === null || value === undefined) {
            cell.innerHTML = '<span class="text-muted">-</span>';
        } else if (column.type === 'boolean') {
            cell.innerHTML = value ?
                '<span class="badge bg-success">Yes</span>' :
                '<span class="badge bg-secondary">No</span>';
        } else if (column.type === 'datetime' && value) {
            try {
                const date = new Date(value);
                if (!isNaN(date)) {
                    cell.textContent = date.toLocaleDateString();
                } else {
                    cell.textContent = value;
                }
            } catch (e) {
                cell.textContent = value;
            }
        } else {
            cell.textContent = value;
        }

        // Add edited class for highlight
        cell.classList.add('edited');
        setTimeout(() => {
            cell.classList.remove('edited');
        }, 3000);
    });
}

// Export data to CSV
function exportData() {
    // Get visible columns only
    const headers = visibleColumns.map(col => col.name);

    // Create CSV content
    let csv = headers.join(',') + '\n';

    tableData.forEach(row => {
        const values = headers.map(header => {
            const value = row[header];
            if (value === null || value === undefined) return '';

            // Escape quotes and wrap in quotes if contains comma or quotes
            const str = String(value);
            if (str.includes(',') || str.includes('"')) {
                return `"${str.replace(/"/g, '""')}"`;
            }
            return str;
        });

        csv += values.join(',') + '\n';
    });

    // Create a blob and download link
    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');

    link.setAttribute('href', url);
    link.setAttribute('download', `{{ table_name }}_export_${new Date().toISOString().slice(0,10)}.csv`);
    link.style.display = 'none';

    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
}

// Clear cache via WebSocket or HTTP
function clearCache() {
    if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({
            command: 'clear_cache'
        }));
        return;
    }

    // HTTP fallback
    fetch(`/api/table/{{ table_name }}/refresh-cache`)
        .then(response => {
            if (!response.ok) {
                throw new Error(`HTTP error: ${response.status}`);
            }
            return response.json();
        })
        .then(data => {
            if (data.success) {
                showToast('Cache cleared successfully');
                refreshData();
            } else {
                throw new Error('Failed to clear cache');
            }
        })
        .catch(error => {
            showError(`Error clearing cache: ${error.message}`);
        });
}

// Update connection status UI
function updateConnectionStatus(status) {
    const statusElem = document.querySelector('.connection-status');
    const statusText = statusElem.querySelector('.status-text');

    statusElem.className = `connection-status ${status}`;

    switch(status) {
        case 'connected':
            statusText.textContent = 'Connected';
            break;
        case 'connecting':
            statusText.textContent = 'Connecting...';
            break;
        case 'disconnected':
            statusText.textContent = 'Disconnected';
            break;
    }
}

// Update data statistics in UI
function updateDataStats() {
    document.getElementById('loaded-count').textContent = loadedRows;
    document.getElementById('total-count').textContent = totalRows;
}

// Show loading overlay with optional progress
function showLoadingOverlay(show, progress = 0, message = '') {
    const overlay = document.getElementById('loading-overlay');

    if (show) {
        overlay.style.display = 'flex';
        if (message) {
            document.getElementById('loading-status').textContent = message;
        }
        if (progress > 0) {
            updateLoadingProgress(progress);
        }
    } else {
        overlay.style.display = 'none';
    }
}

// Update loading progress bar
function updateLoadingProgress(percent, message = '') {
    const progressBar = document.getElementById('loading-progress');
    progressBar.style.width = `${percent}%`;
    progressBar.setAttribute('aria-valuenow', percent);

    if (message) {
        document.getElementById('loading-status').textContent = message;
    }
}

// Show error message
function showError(message) {
    const errorElement = document.getElementById('error-message');
    errorElement.textContent = message;
    errorElement.style.display = 'block';

    // Hide after 5 seconds
    setTimeout(() => {
        errorElement.style.display = 'none';
    }, 5000);

    console.error(message);
}

// Show auto-update message
function showAutoUpdateMessage(message) {
    const messageElement = document.getElementById('auto-update-messages');
    messageElement.textContent = message;

    // Clear after 3 seconds
    setTimeout(() => {
        messageElement.textContent = '';
    }, 3000);
}

// Show toast notification
function showToast(message) {
    // Create toast element
    const toast = document.createElement('div');
    toast.className = 'toast position-fixed top-0 end-0 m-3';
    toast.setAttribute('role', 'alert');
    toast.setAttribute('aria-live', 'assertive');
    toast.setAttribute('aria-atomic', 'true');

    toast.innerHTML = `
        <div class="toast-header">
            <strong class="me-auto">Notification</strong>
            <button type="button" class="btn-close" data-bs-dismiss="toast" aria-label="Close"></button>
        </div>
        <div class="toast-body">
            ${message}
        </div>
    `;

    document.body.appendChild(toast);

    const bsToast = new bootstrap.Toast(toast, { delay: 3000 });
    bsToast.show();

    // Remove from DOM after hiding
    toast.addEventListener('hidden.bs.toast', () => {
        document.body.removeChild(toast);
    });
}

// Event listener to handle window unload
window.addEventListener('beforeunload', function() {
    // Close WebSocket connection cleanly
    if (ws && ws.readyState === WebSocket.OPEN) {
        ws.close();
    }
});
</script>
{% endblock %}